var documenterSearchIndex = {"docs":
[{"location":"BcdiCore.jl/docs/src/#Julia-BCDI-Documentation","page":"About/Installation","title":"Julia BCDI Documentation","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/#About","page":"About/Installation","title":"About","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"The BYU-CXI research group maintains a suite of Julia packages to solve the Bragg Coherent Diffraction Imaging (BCDI) problem in several different regimes and circumstance. ","category":"page"},{"location":"BcdiCore.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"BcdiCore.jl implements all of the Fourier transforms for the Julia BCDI packages. In addition, BcdiCore calculates the loss function used (either L_2 or the MLE estimator) and derivatives of these loss functions.\nBcdiTrad.jl implements projection-based BCDI algorithm. Currently, this is limited to ER, HIO, and shrinkwrap. \nBcdiStrain.jl implements a multi-peak BCDI algorithm developed by the BYU-CXI group. In addition to the alogrithms present in BcdiTrad, BcdiStrain also implements Mount, an operator that switches between peaks.\nBcdiMeso.jl implements a BCDI algorithm that solves in the mesoscale regime. Instead of using projections, this algorithm uses a gradient-based optimization scheme. Additionally, BcdiMeso does not assume a small measurement distance away from the peak.\nBcdiAtomic.jl is an upcoming BCDI package that implements a BCDI algorithm that solves at the atomic scale.\nBcdiMulti.jl is an upcoming BCDI package that implements a multiscale BCDI algorithm that solves at both the mesoscale and the atomic scale.\nBcdiSimulate.jl is an upcoming BCDI package that simulates the BCDI problem. Currently, this is only implimented at the atomic scale.","category":"page"},{"location":"BcdiMeso.jl/docs/src/use/#Overview","page":"Usage","title":"Overview","text":"","category":"section"},{"location":"BcdiMeso.jl/docs/src/use/","page":"Usage","title":"Usage","text":"BcdiMeso implements phase retrieval in operator-style format. This means that the multiplication (*) and power (^) operators are used to apply operators to some current state. This may look like the following:","category":"page"},{"location":"BcdiMeso.jl/docs/src/use/","page":"Usage","title":"Usage","text":"state = State(intens, gVecs, recSupport, x, y, z, rho, ux, uy, uz)\noptimizeState = OptimizeState(state, primitiveRecipLattice, numPeaks)\n\noptimizeState^100 * state","category":"page"},{"location":"BcdiMeso.jl/docs/src/use/","page":"Usage","title":"Usage","text":"This short script applies 100 stochastic gradient descent iterations iterations. This makes it easy to implement very complex recipes for phase retrieval algorithms.","category":"page"},{"location":"BcdiMeso.jl/docs/src/use/#API","page":"Usage","title":"API","text":"","category":"section"},{"location":"BcdiMeso.jl/docs/src/use/","page":"Usage","title":"Usage","text":"BcdiMeso.State\nBcdiMeso.OptimizeState","category":"page"},{"location":"BcdiMeso.jl/docs/src/use/#BcdiMeso.State","page":"Usage","title":"BcdiMeso.State","text":"Create an object that performs an iteration of stochastic gradient descent.\n\nCreate the reconstruction state.\n\n\n\n\n\n","category":"type"},{"location":"BcdiMeso.jl/docs/src/use/#BcdiMeso.OptimizeState","page":"Usage","title":"BcdiMeso.OptimizeState","text":"OptimizeState(state, primitiveRecipLattice, numPeaks)\n\nCreate an object that performs an iteration of stochastic gradient descent.\n\n\n\n\n\n","category":"type"},{"location":"BcdiStrain.jl/README/#BcdiStrain","page":"BcdiStrain","title":"BcdiStrain","text":"","category":"section"},{"location":"BcdiStrain.jl/README/","page":"BcdiStrain","title":"BcdiStrain","text":"<!– (Image: Build Status) –> (Image: )","category":"page"},{"location":"BcdiMeso.jl/README/#BcdiMeso.jl","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"","category":"section"},{"location":"BcdiMeso.jl/README/","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"<!– (Image: Build Status) –> (Image: )","category":"page"},{"location":"BcdiMeso.jl/README/#About","page":"BcdiMeso.jl","title":"About","text":"","category":"section"},{"location":"BcdiMeso.jl/README/","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"Bragg Coherent Diffraction Imaging (BCDI) Meso (Mesoscale) implements phase retrieval for mesoscale models with stochastic gradient descent. Some of the core functionality of this project is implemented in BcdiCore.jl. Additionally, this package is part of a collection of BCDI packages consisting of BcdiAtomic.jl (an atomic scale BCDI solver), BcdiMeso.jl (a mesoscale BCDI Solver), and BcdiMulti.jl (a multiscale BCDI solver).","category":"page"},{"location":"BcdiMeso.jl/README/","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval package.","category":"page"},{"location":"BcdiMeso.jl/README/","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiMeso.jl/README/#Installation","page":"BcdiMeso.jl","title":"Installation","text":"","category":"section"},{"location":"BcdiMeso.jl/README/","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"Currently, BcdiStrain.jl is not registered in the Julia general registry. BcdiTrad.jl can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiMeso.jl/README/","page":"BcdiMeso.jl","title":"BcdiMeso.jl","text":"add BcdiMeso","category":"page"},{"location":"BcdiCore.jl/docs/src/use/atomic/#Mathematical-Definitions","page":"Atomic Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"For the atomic model, G(u) is defined as","category":"page"},{"location":"BcdiCore.jl/docs/src/use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"G(hkl) = sum_j e^-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l)) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"where x_j y_j z_j are atom positions and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. It is important that the hkl value are integers and that they range from -fracn2 to fracn2-1, so both real space and reciprocal space positions must be scaled. The x_jy_jz_j positions should be shifted to lie between 0 to 1 and should be multiplied by 2pi to capture the missing 2 pi scaling in the Fourier transform exponent.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/atomic/#Usage","page":"Atomic Models","title":"Usage","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"Calculating the loss function and its derivative for the atomic model is done in three steps. First, the BcdiCore.AtomicState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"state = AtomicState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"BcdiCore.jl/docs/src/use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.xDeriv,  state.yDeriv, and state.zDeriv.","category":"page"},{"location":"BcdiTrad.jl/docs/src/use/#Overview","page":"Usage","title":"Overview","text":"","category":"section"},{"location":"BcdiTrad.jl/docs/src/use/","page":"Usage","title":"Usage","text":"Similar to pynx and others?, BcdiTrad implements projection-based algorithms in operator-style format. This means that the multiplication (*) and power (^) operators are used to apply operators to some current state. This may look like the following:","category":"page"},{"location":"BcdiTrad.jl/docs/src/use/","page":"Usage","title":"Usage","text":"er = BcdiTrad.ER()\nhio = BcdiTrad.HIO(0.9)\nstate = BcdiTrad.State(intensities, trues(size(intensities)))\n\n(er * hio^20)^5 * state","category":"page"},{"location":"BcdiTrad.jl/docs/src/use/","page":"Usage","title":"Usage","text":"This short script applies 20 HIO iterations and one ER iterations for a total of 5 times. This makes it easy to implement very complex recipes for phase retrieval algorithms.","category":"page"},{"location":"BcdiTrad.jl/docs/src/use/#API","page":"Usage","title":"API","text":"","category":"section"},{"location":"BcdiTrad.jl/docs/src/use/","page":"Usage","title":"Usage","text":"BcdiTrad.State\nBcdiTrad.ER\nBcdiTrad.HIO\nBcdiTrad.Shrink\nBcdiTrad.Center","category":"page"},{"location":"BcdiTrad.jl/docs/src/use/#BcdiTrad.State","page":"Usage","title":"BcdiTrad.State","text":"State(intensities, recSupport)\n\nCreate a reconstruction object. The intensities and a mask over reciprocal space indicating trusted intensities need to be passed in.\n\n\n\n\n\n","category":"type"},{"location":"BcdiTrad.jl/docs/src/use/#BcdiTrad.ER","page":"Usage","title":"BcdiTrad.ER","text":"ER()\n\nCreate an object that applies an iteration of ER\n\n\n\n\n\n","category":"type"},{"location":"BcdiTrad.jl/docs/src/use/#BcdiTrad.HIO","page":"Usage","title":"BcdiTrad.HIO","text":"HIO(beta)\n\nCreate an object that applies an iteration of HIO\n\n\n\n\n\n","category":"type"},{"location":"BcdiTrad.jl/docs/src/use/#BcdiTrad.Shrink","page":"Usage","title":"BcdiTrad.Shrink","text":"Shrink(threshold, sigma, state)\n\nCreate an object that applies shrinkwrap\n\n\n\n\n\n","category":"type"},{"location":"BcdiTrad.jl/docs/src/use/#BcdiTrad.Center","page":"Usage","title":"BcdiTrad.Center","text":"Center(state)\n\nCreate an object that centers the current state\n\n\n\n\n\n","category":"type"},{"location":"BcdiCore.jl/README/#BcdiCore","page":"BcdiCore","title":"BcdiCore","text":"","category":"section"},{"location":"BcdiCore.jl/README/","page":"BcdiCore","title":"BcdiCore","text":"<!– (Image: Build Status) –> (Image: ) <!– (Image: ) –>","category":"page"},{"location":"BcdiCore.jl/README/#About","page":"BcdiCore","title":"About","text":"","category":"section"},{"location":"BcdiCore.jl/README/","page":"BcdiCore","title":"BcdiCore","text":"Bragg Coherent Diffraction Imaging (BCDI) Core implements some of the core functionality used for future projects BcdiAtomic.jl (an atomic scale BCDI solver), BcdiMeso.jl (a mesoscale BCDI Solver), BcdiMulti.jl (a multiscale BCDI solver), BcdiTrad.jl (a BCDI solver using projection algorithms), and BcdiStrain (a BCDI solver for mesoscale using projection algorithms). BcdiCore.jl implements the loss functions and derivatives of loss functions used in these packages.","category":"page"},{"location":"BcdiCore.jl/README/","page":"BcdiCore","title":"BcdiCore","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval core package.","category":"page"},{"location":"BcdiCore.jl/README/","page":"BcdiCore","title":"BcdiCore","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiCore.jl/README/#Installation","page":"BcdiCore","title":"Installation","text":"","category":"section"},{"location":"BcdiCore.jl/README/","page":"BcdiCore","title":"BcdiCore","text":"Currently, BcdiCore.jl is not registered in the Julia general registry and can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiCore.jl/README/","page":"BcdiCore","title":"BcdiCore","text":"add BcdiCore","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/#Mathematical-Definitions","page":"Multiscale Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"The multiscale model is a combination of an atomic scale and a mesoscale model. In this case,  G(hkl) is defined as","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"G(hkl) = G_a(hkl) + G_m(hkl)","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"where a signifies the atomic model and m signifies the mesoscale model.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/#Usage","page":"Multiscale Models","title":"Usage","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the BcdiCore.MultiState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"state = MultiState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, mx, my, mz, rho, ux, uy, uz, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"Here x, y, z are atomic positions and mx, my, mz are the real space locations of the mesoscale model.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/multi/","page":"Multiscale Models","title":"Multiscale Models","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.xDeriv,  state.yDeriv, and state.zDeriv, state.rhoDeriv, state.uxDeriv,  state.uyDeriv, and state.uzDeriv.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/#Mathematical-Definitions","page":"Traditional Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"Similar to the mesoscale model, G(u) is initially defined as","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"where x_j y_j z_j are real space positions, ux_j uy_j uz_j are diplacement vectors, and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. However, we assume that, because the distance from the scattering vector and the displacement vectors are small, u cdot h is negligible. So we are left with","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j G_h + uy_j G_k + uz_j G_l) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"Then, we combine the entire rho_j e^-i (ux_j G_h + uy_j G_k + uz_j G_l) quantity as one variable and get","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j psi_j e^-i (x_j h + y_j k + uz_j l) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"In this case, this is an ordinary Fourier transform, so we put the factor of 2pi back into G(hkl) to get","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j psi_j e^-2 pi i (x_j h + y_j k + uz_j l) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/#Usage","page":"Traditional Models","title":"Usage","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"Calculating the loss function and its derivative for the traditional model is done in two steps. First, the BcdiCore.TradState struct is created. Then, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"state = TradState(losstype, scale, intens, realSpace)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"BcdiCore.jl/docs/src/use/trad/","page":"Traditional Models","title":"Traditional Models","text":"If the derivative is requested with the getDeriv variable, the result us stored in state.deriv.","category":"page"},{"location":"BcdiTrad.jl/docs/src/#BcdiTrad.jl-Documentation","page":"About/Installation","title":"BcdiTrad.jl Documentation","text":"","category":"section"},{"location":"BcdiTrad.jl/docs/src/#About","page":"About/Installation","title":"About","text":"","category":"section"},{"location":"BcdiTrad.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Bragg Coherent Diffraction Imaging (BCDI) Trad (Traditional) implements projection-based phase retrieval algorithms.","category":"page"},{"location":"BcdiTrad.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval core package.","category":"page"},{"location":"BcdiTrad.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiTrad.jl/docs/src/#Installation","page":"About/Installation","title":"Installation","text":"","category":"section"},{"location":"BcdiTrad.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"BcdiTrad.jl is registered in the Julia general registry and can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiTrad.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"add BcdiTrad","category":"page"},{"location":"BcdiStrain.jl/docs/src/use/#Overview","page":"Usage","title":"Overview","text":"","category":"section"},{"location":"BcdiStrain.jl/docs/src/use/","page":"Usage","title":"Usage","text":"BcdiStrain implements projection-based algorithms in operator-style format. This means that the multiplication (*) and power (^) operators are used to apply operators to some current state. This may look like the following:","category":"page"},{"location":"BcdiStrain.jl/docs/src/use/","page":"Usage","title":"Usage","text":"er = BcdiTrad.ER()\nhio = BcdiTrad.HIO(0.9)\nstate = BcdiTrad.State(intensities, trues(size(intensities)))\n\n(er * hio^20)^5 * state","category":"page"},{"location":"BcdiStrain.jl/docs/src/use/","page":"Usage","title":"Usage","text":"This short script applies 20 HIO iterations and one ER iterations for a total of 5 times. This makes it easy to implement very complex recipes for phase retrieval algorithms.","category":"page"},{"location":"BcdiStrain.jl/docs/src/use/#API","page":"Usage","title":"API","text":"","category":"section"},{"location":"BcdiStrain.jl/docs/src/use/","page":"Usage","title":"Usage","text":"BcdiStrain.State\nBcdiStrain.ER\nBcdiStrain.HIO\nBcdiStrain.Shrink\nBcdiStrain.Center\nBcdiStrain.Mount","category":"page"},{"location":"BcdiStrain.jl/docs/src/use/#BcdiStrain.State","page":"Usage","title":"BcdiStrain.State","text":"State(intensities, recSupport)\n\nCreate a reconstruction object. The intensities and a mask over reciprocal space indicating trusted intensities need to be passed in.\n\n\n\n\n\n","category":"type"},{"location":"BcdiStrain.jl/docs/src/use/#BcdiStrain.ER","page":"Usage","title":"BcdiStrain.ER","text":"ER()\n\nCreate an object that applies an iteration of ER\n\n\n\n\n\n","category":"type"},{"location":"BcdiStrain.jl/docs/src/use/#BcdiStrain.HIO","page":"Usage","title":"BcdiStrain.HIO","text":"HIO(beta)\n\nCreate an object that applies an iteration of HIO\n\n\n\n\n\n","category":"type"},{"location":"BcdiStrain.jl/docs/src/use/#BcdiStrain.Shrink","page":"Usage","title":"BcdiStrain.Shrink","text":"Shrink(threshold, sigma, state)\n\nCreate an object that applies shrinkwrap\n\n\n\n\n\n","category":"type"},{"location":"BcdiStrain.jl/docs/src/use/#BcdiStrain.Center","page":"Usage","title":"BcdiStrain.Center","text":"Center(state)\n\nCreate an object that centers the current state\n\n\n\n\n\n","category":"type"},{"location":"BcdiStrain.jl/docs/src/use/#BcdiStrain.Mount","page":"Usage","title":"BcdiStrain.Mount","text":"Mount(beta, state, primitiveRecipLattice)\n\nCreate an object that switches between peaks.\n\n\n\n\n\n","category":"type"},{"location":"BcdiMeso.jl/docs/src/#BcdiMeso.jl-Documentation","page":"About/Installation","title":"BcdiMeso.jl Documentation","text":"","category":"section"},{"location":"BcdiMeso.jl/docs/src/#About","page":"About/Installation","title":"About","text":"","category":"section"},{"location":"BcdiMeso.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Bragg Coherent Diffraction Imaging (BCDI) Meso (Mesoscale) implements phase retrieval for mesoscale models with stochastic gradient descent.","category":"page"},{"location":"BcdiMeso.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval package.","category":"page"},{"location":"BcdiMeso.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiMeso.jl/docs/src/#Installation","page":"About/Installation","title":"Installation","text":"","category":"section"},{"location":"BcdiMeso.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"BcdiStrain.jl is registered in the Julia general registry and can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiMeso.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"add BcdiMeso","category":"page"},{"location":"BcdiStrain.jl/docs/src/#BcdiStrain.jl-Documentation","page":"About/Installation","title":"BcdiStrain.jl Documentation","text":"","category":"section"},{"location":"BcdiStrain.jl/docs/src/#About","page":"About/Installation","title":"About","text":"","category":"section"},{"location":"BcdiStrain.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Bragg Coherent Diffraction Imaging (BCDI) Strain implements projection-based phase retrieval algorithms.","category":"page"},{"location":"BcdiStrain.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval package.","category":"page"},{"location":"BcdiStrain.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiStrain.jl/docs/src/#Installation","page":"About/Installation","title":"Installation","text":"","category":"section"},{"location":"BcdiStrain.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"Currently, BcdiStrain.jl is not registered in the Julia general registry and can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiStrain.jl/docs/src/","page":"About/Installation","title":"About/Installation","text":"add BcdiStrain","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/#Mathematical-Definitions","page":"Mesoscale Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Similar to the atomic model, G(u) is initially defined as","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"G(hkl) = sum_j e^-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l)) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"where x_j y_j z_j are atom positions and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. However, x_j y_j z_j can be thought of as an addition of lattice spacings and displacement vectors, i.e.  x_j+ux_j y_j+uy_j z_j+uz_j. Then, if G_hG_kG_l are reciprocal lattice vectors, we find that x cdot G is an integer multiple of 2pi, so it does not affect the simulated electric field. We are then left with","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"G(hkl) = sum_j e^-i (x_j G_h + y_j G_k + uz_j G_l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Coarse graining to get a mesoscale model, we get","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Again, it is important that the hkl value are integers and that they range from -fracn2 to fracn2-1, so both real space and reciprocal space positions must be scaled. The x_jy_jz_j positions should be shifted to lie between 0 to 1 and should be multiplied by 2pi to capture the missing 2 pi scaling in the Fourier transform exponent.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/#Usage","page":"Mesoscale Models","title":"Usage","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the BcdiCore.MesoState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"state = MesoState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, rho, ux, uy, uz, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"BcdiCore.jl/docs/src/use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.rhoDeriv, state.uxDeriv,  state.uyDeriv, and state.uzDeriv.","category":"page"},{"location":"README/#BcdiExamples","page":"BcdiExamples","title":"BcdiExamples","text":"","category":"section"},{"location":"BcdiTrad.jl/README/#BcdiTrad","page":"BcdiTrad","title":"BcdiTrad","text":"","category":"section"},{"location":"BcdiTrad.jl/README/","page":"BcdiTrad","title":"BcdiTrad","text":"<!– (Image: Build Status) –> (Image: )","category":"page"},{"location":"BcdiTrad.jl/README/#About","page":"BcdiTrad","title":"About","text":"","category":"section"},{"location":"BcdiTrad.jl/README/","page":"BcdiTrad","title":"BcdiTrad","text":"Bragg Coherent Diffraction Imaging (BCDI) Trad (Traditional) implements projection-based phase retrieval algorithms. Some of the core functionality of this project is implemented in BcdiCore.jl. Additionally, this package is part of a collection of BCDI packages consisting of BcdiAtomic.jl (an atomic scale BCDI solver), BcdiMeso.jl (a mesoscale BCDI Solver), and BcdiMulti.jl (a multiscale BCDI solver).","category":"page"},{"location":"BcdiTrad.jl/README/","page":"BcdiTrad","title":"BcdiTrad","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval core package.","category":"page"},{"location":"BcdiTrad.jl/README/","page":"BcdiTrad","title":"BcdiTrad","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiTrad.jl/README/#Installation","page":"BcdiTrad","title":"Installation","text":"","category":"section"},{"location":"BcdiTrad.jl/README/","page":"BcdiTrad","title":"BcdiTrad","text":"Currently, BcdiTrad.jl is registered in the Julia general registry and can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiTrad.jl/README/","page":"BcdiTrad","title":"BcdiTrad","text":"add BcdiTrad","category":"page"},{"location":"#Julia-BCDI-Documentation","page":"Julia BCDI","title":"Julia BCDI Documentation","text":"","category":"section"},{"location":"#About","page":"Julia BCDI","title":"About","text":"","category":"section"},{"location":"","page":"Julia BCDI","title":"Julia BCDI","text":"The BYU-CXI research group maintains a suite of Julia packages to solve the Bragg Coherent Diffraction Imaging (BCDI) problem in several different regimes and circumstance. ","category":"page"},{"location":"","page":"Julia BCDI","title":"Julia BCDI","text":"BcdiCore.jl implements all of the Fourier transforms for the Julia BCDI packages. In addition, BcdiCore calculates the loss function used (either L_2 or the MLE estimator) and derivatives of these loss functions.\nBcdiTrad.jl implements projection-based BCDI algorithm. Currently, this is limited to ER, HIO, and shrinkwrap. \nBcdiStrain.jl implements a multi-peak BCDI algorithm developed by the BYU-CXI group. In addition to the alogrithms present in BcdiTrad, BcdiStrain also implements Mount, an operator that switches between peaks.\nBcdiMeso.jl implements a BCDI algorithm that solves in the mesoscale regime. Instead of using projections, this algorithm uses a gradient-based optimization scheme. Additionally, BcdiMeso does not assume a small measurement distance away from the peak.\nBcdiAtomic.jl is an upcoming BCDI package that implements a BCDI algorithm that solves at the atomic scale.\nBcdiMulti.jl is an upcoming BCDI package that implements a multiscale BCDI algorithm that solves at both the mesoscale and the atomic scale.\nBcdiSimulate.jl is an upcoming BCDI package that simulates the BCDI problem. Currently, this is only implimented at the atomic scale.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"In general, BcdiCore.jl will be called by developers of phase retrieval codes, not end users. BcdiCore.jl implements loss functions and derivatives of loss functions for atomic models, mesoscale models, multiscale models, and traditional projection-based methods.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/#Available-loss-functions","page":"Overview","title":"Available loss functions","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"Currently, BcdiCore.jl implements two types of losses, the average L_2 norm and the average log-likelihood. ","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"Explicitly, the average L_2 loss is defined as","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"L_2 = frac1N sum_u left( lvert G(u) rvert - lvert F(u) rvert right)^2","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"where G(u) is the simulated electric field, lvert F(u) rvert^2 is the measured intensity at a point u in reciprocal space, and N is the total number of meaurement points.","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"The average log-likelihood (for the Poisson distribution) is defined as","category":"page"},{"location":"BcdiCore.jl/docs/src/use/overview/","page":"Overview","title":"Overview","text":"ell = frac1N sum_u lvert G(u) rvert^2 - lvert F(u) rvert^2 lnleft(lvert G(u) rvert^2 right)","category":"page"},{"location":"BcdiCore.jl/docs/src/main/#BcdiCore-Documentation","page":"BcdiCore Documentation","title":"BcdiCore Documentation","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/main/#About","page":"BcdiCore Documentation","title":"About","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/main/","page":"BcdiCore Documentation","title":"BcdiCore Documentation","text":"Bragg Coherent Diffraction Imaging (BCDI) Core implements some of the core functionality used for future projects BcdiAtomic.jl (an atomic scale BCDI solver), BcdiMeso.jl (a mesoscale BCDI Solver), BcdiMulti.jl (a multiscale BCDI solver), BcdiTrad.jl (a BCDI solver using projection algorithms), and BcdiStrain (a BCDI solver for mesoscale using projection algorithms). BcdiCore.jl implements the loss functions and derivatives of loss functions used in these packages.","category":"page"},{"location":"BcdiCore.jl/docs/src/main/","page":"BcdiCore Documentation","title":"BcdiCore Documentation","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval core package.","category":"page"},{"location":"BcdiCore.jl/docs/src/main/","page":"BcdiCore Documentation","title":"BcdiCore Documentation","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"BcdiCore.jl/docs/src/main/#Installation","page":"BcdiCore Documentation","title":"Installation","text":"","category":"section"},{"location":"BcdiCore.jl/docs/src/main/","page":"BcdiCore Documentation","title":"BcdiCore Documentation","text":"Currently, BcdiCore.jl is not registered in the Julia general registry and can be installed by running in the REPL package manager (]):","category":"page"},{"location":"BcdiCore.jl/docs/src/main/","page":"BcdiCore Documentation","title":"BcdiCore Documentation","text":"add BcdiCore","category":"page"}]
}
